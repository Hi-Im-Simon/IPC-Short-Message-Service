UWAGA! W protokole używane będą stałe (pisane wielkimi literami) zdefiniowane w pliku "servers_config.h", "messages.h" i "server.c"

* Serwer komunikuje się z klientem za pomocą identyfikatora <FIRST_USER_ID, FIRST_USER_ID+MAX_USERS_NUMBER) użytkownika za wyjątkiem:
- wysyłania wiadomości (kanałowe userId*MAX_USERS_NUMBER+1, prywatne userId*MAX_USERS_NUMBER+2)
- mechanizmu heartbeat (userId*MAX_USERS_NUMBER+3)
- wysyłania odpowiedzi na próbę zalogowania (SERVER_ENTER_MESSAGE_TYPE)
* Serwer odbiera od klienta wiadomości o zdarzeniach za pomocą identyfikatorów mniejszych od FIRST_USER_ID oraz w przypadku heartbeata o identyfikatorze serId*MAX_USERS_NUMBER+3.
* Każda wiadomość to struktura message zdefiniowana w pliku "messages.h". Ma ona dwa parametry - identyfikator (o którym było wyżej pisane) oraz dane. Parametr dane jest unią typu message_data.
* W message_data znajdują się wszystkie możliwe typy danych, które są wysyłane. 
* Dokładny opis struktur z message_data:
- client_enter_message -> struktura, którą wysyła użytkownik, gdy chce się zalogować. Zawiera tylko nazwę użytkownika. (id CLIENT_ENTER_MESSAGE_TYPE)
- server_enter_message -> struktura, którą serwer wysyła użytkownikowi jako odpowiedź na próbę zalogowania. Zawiera nazwę użytkownika (w celu identyfikacji), nazwę kanału publicznego, do którego należy każdy użytkownik i id użytkownika po którym klient będzie komunikował się z serwerem. (id SERVER_ENTER_MESSAGE_TYPE)
- user_message -> prosta struktura, która wysyła do serwera jakieś żądanie np. o listę użytkowników. Jej jedyny parametr to id użytkownika, aby serwer wiedział komu odpowiedzieć. Poprzez id wiadomości wykonywana jest odpowiednia akcja.
- server_list_begin_message -> struktura, którą serwer wysyła podczas prośby o listy. Zawiera ona długość listy.
- server_list_element_of_users_message -> element listy użytkowników (nazwa użytkownika i informacja o byciu online)
- server_list_element_of_channels_message -> element listy kanałów (nazwa kanału)
- client_channel_message -> struktura, którą klient prosi o dołączenie na jakiś kanał (nazwa kanału i id użytkownika)
- server_message -> struktura, którą serwer w prosty sposób (za pomocą kodu) odpowiada na żądanie użytkownika
- server_list_element_of_channels_with_users_message -> element listy kanałów i ich użytkowników (nazwa kanału i tablica nazw użytkowników)
- client_public_channel_message -> wiadomość od klienta w celu wysłania tekstu na kanał (data, treść, id użytkownika, nazwa kanału)
- client_private_message -> wiadomość od klienta w celi wysłania prywatnej wiadomości do innego użytkownika (data, treść, id nadawcy, nazwa odbiorcy)
- server_public_channel_message -> wiadomość, którą otrzymuje każdy użytkownik (w tle) odpowiedniego kanału (data, treść, nazwa nadawcy, nazwa kanału).
- server_private_message -> wiadomość, którą otrzymuje odpowiedni użytkownik od serwera z treścią wiadomości prywatnej (data, treść, nazwa nadawcy, nazwa odbiorcy)
* Logowanie (lub zakładanie konta, jest to u nas tożsame) polega na tym, że klient wysyła wiadomość do serwera, a następnie czeka na informację czy udało mu się zalogować. Jeżeli nie to program klienta kończy działanie.
* Wysyłanie list odbywa się za pomocą wysłania wiadomości o ilości nadchodzących danych i kolejno wysyłaniu tych danych tzn. realizowane jest za pomocą wielu wiadomości.
* Wiadomości publiczne (kanałowe) odbierane są za pomocą identyfikatora wiadomości userId*MAX_USERS_NUMBER+1 i działają jako proces potomny
* Wiadomości prywatne odbierane są za pomocą identyfikatora wiadomości userId*MAX_USERS_NUMBER+2 i działają jako proces potomny
* Heartbeat:
- u klienta realizowany jest jako proces potomny, który odbiera ostrzeżenia o długiej nieaktywności oraz komunikaty o tym, że użytkownik został wylogowany (zbyt długa nieaktywność). Dodatkowo podczas każdej wiadomości oraz komendy (nawet błędnej) wysyłany jest sygnał o życiu (komunikat o id userId*MAX_USERS_NUMBER+4)
- u serwera realizowany jest jako proces potomny dla każdego użytkownika. Proces jest tworzony podczas logowania użytkownika i kończony podczas wylogowania użytkownika. Działa w taki sposób, że w każdej iteracji nieskończonej pętli tworzy proces potomny, który wysyła ostrzeżenia i informacje o wylogowaniu. W tym samym czasie proces macierzysty czeka na komunikat o życiu od klienta (id userId*MAX_USERS_NUMBER+4). Jeżeli otrzyma go odpowiednio szybko to zabija swoje dziecko. W innym przypadku dziecko wyśle to serwera (do procesu macierzystego swojego procesu macierzystego) komunikat o id SERVER_NO_HEARTBEAT_MESSAGE_TYPE, który spowoduje wylogowanie użytkownika.
* Ostatnie 10 wiadomości:
- gdy użytkownik się zaloguje dostanie 10 ostatnich wiadomości z każdego ze swoich kanałów (dostanie je tak jak otrzymuje normalne wiadomości publiczne, tą samą drogą)
- gdy użytkownik dołączy do istniejącego kanału również wyświetli mu się 10 ostatnich wiadomości na tym kanale
* Użytkownik może dołączyć i odejść z każdego kanału oprócz kanału publicznego
* Użytkownik może się wylogować, ale nie może usunąć konta. Gdy zaloguje się ponownie będzie należał do tych samych kanałów
* Wylogowanie powinno nastąpić za pomocą komendy /wyloguj, a nie zakończenia procesu. Jeżeli zostanie zrealizowane za pomocą zakończenia procesu to klient będzie musiał poczekać, aż mechanizm heartbeat wyloguje użytkownika i dopiero wtedy będzie mógł zalogować się ponownie. Nie ma możliwości, że na tym samym koncie jest dwóch klientów.
* Wyłączenie serwera powinno nastąpić za pomocą wpisania 'q' na standardowym wejściu. Jeżeli nie zostanie to zrobione, to kolejka IPC nie zostanie poprawnie zamknięta.
